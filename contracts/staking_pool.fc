#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";


global int   storage::pool_id;               ;; Uint32. Unique index for each pool factory;
global slice storage::admin_address;         ;; MsgAddressStd. Address that will receive commissions;
global slice storage::creator_address;       ;; MsgAddressStd. Address of this staking pool creator
global cell  storage::jetton_content;        ;; HashMapE. Standart jetton content dict
global cell  storage::jetton_wallet_code;    ;; Cell. Stake wallet code

global slice storage::lock_wallet_address;   ;; MsgAddressStd. Address of jetton wallet for staking jetton
global int   storage::min_deposit;           ;; Coins. Min staking deposit
global int   storage::max_deposit;           ;; Coins. Max staking deposit
global int   storage::tvl;                   ;; Coins. Current TVL
global int   storage::tvl_with_multipliers;  ;; Coins. Current TVL with multipliers taken into account

global cell  storage::reward_jettons;        ;; HashMapE. jetton_wallet_address (MsgAddressStd) -> distributed_rewards (uint256), HashMapE(index (uint16) -> farming_speed (coins), start_time (uint32), end_time (uint32))
global cell  storage::rewards_multipliers;   ;; HashMapE. lock_period (uint32) -> rewards_multiplier (uint16)

global int   storage::unstake_commission;    ;; Uint32. Commission rate for instant unstakes
global int   storage::unstake_fee;           ;; Coins. Const JVault's TON fee
global int   storage::collected_commissions; ;; Coins. Commissions collected from instant unstakes  

global int   storage::rewards_commission;    ;; Uint16. JVault's commission as percent of staking rewards. Commission rate = commission_factor / commission_devider.


() load_data() impure inline {
    slice ds = get_data().begin_parse();
    storage::pool_id               = ds~load_uint(32);
    storage::admin_address         = ds~load_msg_addr();
    storage::creator_address       = ds~load_msg_addr();
    storage::jetton_content        = ds~load_dict();
    storage::jetton_wallet_code    = ds~load_ref();
    storage::lock_wallet_address   = ds~load_msg_addr();

    slice ds2 = ds~load_ref().begin_parse();
    storage::min_deposit           = ds2~load_coins();
    storage::max_deposit           = ds2~load_coins();
    storage::tvl                   = ds2~load_coins();
    storage::tvl_with_multipliers  = ds2~load_coins();
    storage::reward_jettons        = ds2~load_dict();
    storage::rewards_multipliers   = ds2~load_dict();
    storage::unstake_commission    = ds2~load_uint(32);
    storage::unstake_fee           = ds2~load_coins();
    storage::collected_commissions = ds2~load_coins();
    storage::rewards_commission    = ds2~load_uint(16);
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_uint(storage::pool_id, 32)
            .store_slice(storage::admin_address)
            .store_slice(storage::creator_address)
            .store_dict(storage::jetton_content)
            .store_ref(storage::jetton_wallet_code)
            .store_slice(storage::lock_wallet_address)
            .store_ref(
                begin_cell()
                    .store_coins(storage::min_deposit)
                    .store_coins(storage::max_deposit)
                    .store_coins(storage::tvl)
                    .store_coins(storage::tvl_with_multipliers)
                    .store_dict(storage::reward_jettons)
                    .store_dict(storage::rewards_multipliers)
                    .store_uint(storage::unstake_commission, 32)
                    .store_coins(storage::unstake_fee)
                    .store_coins(storage::collected_commissions)
                    .store_uint(storage::rewards_commission, 16)
                .end_cell()
            )
        .end_cell()
    );
}

(slice) calculate_stake_wallet_address(slice owner_address, int lock_period) {
    return begin_cell()
                .store_uint(0, 2)
                .store_maybe_ref(storage::jetton_wallet_code)
                .store_maybe_ref(
                    begin_cell()
                        .store_slice(my_address())
                        .store_coins(0)
                        .store_slice(owner_address)
                        .store_uint(1, 1 + 16 + 32 + 1)
                    .end_cell()
                )
                .store_uint(0, 1)
            .end_cell().begin_parse();

}

(int) get_distributed_rewards(int farming_speed, int start_time, int time_now) inline {
    return muldiv(muldiv(farming_speed, farming_speed_devider, distributed_rewards_devider), time_now - start_time, storage::tvl_with_multipliers);
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }

    load_data();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::transfer_notification) { 
        int transferred_jettons = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();

        ;; try {
            int inner_op = in_msg_body~load_uint(32);

            if (inner_op == op::stake_jettons) {
                throw_unless(exc::incorrect_jetton, equal_slices(sender_address, storage::lock_wallet_address));
                throw_if(exc::less_than_min_deposit, transferred_jettons < storage::min_deposit);
                throw_if(exc::more_than_max_deposit, transferred_jettons > storage::max_deposit);

                int lock_period = in_msg_body~load_uint(32);
                (_, int success) = storage::rewards_multipliers.udict_get?(32, lock_period);
                throw_unless(exc::incorrect_lock_period, success);

                cell payload = begin_cell()
                                    .store_uint(op::stake_jettons, 32)
                                    .store_uint(query_id, 64)
                                    .store_coins(transferred_jettons)
                                    .store_coins(storage::max_deposit)
                                .end_cell();

                send_cell_message(calculate_stake_wallet_address(from_address, lock_period), 0, payload, mode::carry_remaining_gas);
                return ();
            } 

            elseif (inner_op == op::add_rewards) {
                throw_unless(exc::incorrect_sender, equal_slices(from_address, storage::creator_address));
                throw_unless(exc::out_of_gas, msg_value > gas::jetton_transfer);
                (slice rewards_info_slice, int success) = storage::reward_jettons.dict_get?(267, sender_address);
                throw_unless(exc::incorrect_jetton, success);
                
                
                int rewards_to_add = muldiv(transferred_jettons, commission_devider, commission_devider + storage::rewards_commission);
                int commission = transferred_jettons - rewards_to_add;

                int start_time = in_msg_body~load_uint(32);
                int end_time = in_msg_body~load_uint(32);
                throw_unless(exc::incorrect_distribution_period, (now() < start_time) & (start_time < end_time));
                int farming_speed = muldiv(rewards_to_add, farming_speed_devider, end_time - start_time);
                
                int distributed_rewards = rewards_info_slice~load_uint(256);
                cell rewards_deposits = rewards_info_slice~load_dict();
                (int max_index, _, int success) = rewards_deposits.udict_get_max?(16);
                max_index = success ? max_index + 1 : 0;
                rewards_deposits~udict_set_builder(16, max_index, begin_cell().store_coins(farming_speed).store_uint(start_time, 32).store_uint(end_time, 32));
                storage::reward_jettons~dict_set_builder(267, sender_address, begin_cell().store_uint(distributed_rewards, 256).store_dict(rewards_deposits));

                send_jettons(query_id, commission, storage::admin_address, from_address, sender_address, 0, mode::carry_remaining_gas, 
                             1, begin_cell().store_uint(0, 32).store_slice("JVault's rewards commission").end_cell());

                save_data();
                return ();
            }
        ;; } catch (_, n) {
        
        ;; }
    }

    if (op == op::add_reward_jettons) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::creator_address));
        cell wallets_dict = in_msg_body~load_dict();
        (int key, slice reward_jetton_wallet, int success) = wallets_dict.udict_get_min?(16);
        while (success) {
            storage::reward_jettons~dict_add_builder?(267, reward_jetton_wallet, begin_cell().store_int(0, 257));
            (key, reward_jetton_wallet, success) = wallets_dict.udict_get_next?(16, key);
        }
        save_data();
        return ();
    }

    if (op == op::claim_commissions) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::creator_address));
        throw_unless(exc::out_of_gas, msg_value > gas::jetton_transfer);

        send_jettons(query_id, storage::collected_commissions, sender_address, sender_address, storage::lock_wallet_address, 0,
                     mode::carry_remaining_gas, 1, begin_cell().store_uint(0, 32).store_slice("Unstake commissions claimed").end_cell());
        storage::collected_commissions = 0;
        save_data();
        return ();
    }

    ;; check that message is from correct stake_wallet_address
    slice stake_owner_address = in_msg_body~load_msg_addr();
    int lock_period = in_msg_body~load_uint(32);
    slice stake_wallet_address = calculate_stake_wallet_address(stake_owner_address, lock_period);
    throw_unless(exc::incorrect_sender, equal_slices(stake_wallet_address, sender_address));

    if (op == op::cancel_stake) {        
        int staked_amount = in_msg_body~load_coins();
        send_jettons(query_id, staked_amount, stake_owner_address, stake_owner_address, storage::lock_wallet_address, 
                     0, mode::carry_remaining_gas, 1, begin_cell().store_uint(0, 32).store_slice("Stake was unsuccessfull").end_cell());
        return ();
    }

    if (op == op::approve_stake) {
        int prev_user_jettons = in_msg_body~load_coins();
        int new_added_jettons = in_msg_body~load_coins();
        cell user_rewards_dict = in_msg_body~load_dict();

        (slice rewards_multiplier_slice, int success) = storage::rewards_multipliers.udict_get?(32, lock_period);
        int rewards_multiplier = rewards_multiplier_slice~load_uint(16);
        
        (slice reward_jetton, slice rewards_info_slice, int success) = storage::reward_jettons.dict_get_min?(267);
        while (success) {
            int distributed_rewards = rewards_info_slice~load_uint(256);
            cell rewards_deposits = rewards_info_slice~load_dict();
            
            (int index, slice rewards_deposit_slice, int success2) = rewards_deposits.udict_get_min?(16);
            while (success2) {
                int farming_speed = rewards_deposit_slice~load_coins();
                int start_time = rewards_deposit_slice~load_uint(32);
                int time_now = now();
                if (start_time < time_now) {
                    int end_time = rewards_deposit_slice~load_uint(32);
                    if (end_time <= time_now) {
                        rewards_deposits~udict_delete?(32, index);
                        time_now = end_time;
                    }
                    distributed_rewards += get_distributed_rewards(farming_speed, start_time, time_now);
                    rewards_deposits~udict_set_builder(16, index, begin_cell().store_coins(farming_speed).store_uint(start_time, 32).store_uint(end_time, 32));
                }
            }
            
            (slice prev_user_rewards_slice, int success3) = user_rewards_dict.dict_get?(267, reward_jetton);
            int prev_user_distributed_rewards = 0;
            int user_unclaimed_rewards = 0;
            if (success3) {
                prev_user_distributed_rewards = prev_user_rewards_slice~load_uint(256);
                user_unclaimed_rewards = prev_user_rewards_slice~load_coins();
            }
            user_unclaimed_rewards += muldiv(distributed_rewards - prev_user_distributed_rewards, prev_user_jettons, distributed_rewards_devider);
                    
            storage::reward_jettons~dict_set_builder(267, reward_jetton, begin_cell().store_uint(distributed_rewards, 256).store_dict(rewards_deposits));
            user_rewards_dict~dict_set_builder(267, reward_jetton, begin_cell().store_uint(distributed_rewards, 256).store_coins(user_unclaimed_rewards));
            (reward_jetton, rewards_info_slice, success) = storage::reward_jettons.dict_get_next?(267, reward_jetton);
        }

        builder payload = begin_cell().store_uint(op::update_rewards, 32).store_uint(query_id, 64).store_dict(user_rewards_dict);
        send_builder_message(sender_address, 0, payload, mode::carry_remaining_gas);

        storage::tvl += new_added_jettons;
        storage::tvl_with_multipliers += muldiv(new_added_jettons, rewards_multiplier, rewards_devider);
        
        save_data();
        return ();
    }

    if (op == op::send_claimed_rewards) {
        raw_reserve(0, 4);

        int user_jetton_balance = in_msg_body~load_coins();
        cell user_rewards_dict = in_msg_body~load_dict();
        cell jettons_to_claim = in_msg_body~load_dict();  ;; HashMapE. jetton_address (MsgAddressStd) -> nothing (int1)

        (slice reward_jetton, _, int success) = jettons_to_claim.dict_get_min?(267);
        int required_gas = 0;

        int should_update_rewards = false;  ;; надо ли удалять элементы из storage::reward_jettons для оптимизации? 
        while (success) {
            (slice rewards_info_slice, int jetton_exists) = storage::reward_jettons.dict_get?(267, reward_jetton);
            if (jetton_exists) {
                int should_update_rewards2 = false;
                int distributed_rewards = rewards_info_slice~load_uint(256);
                cell rewards_deposits = rewards_info_slice~load_dict();

                (int index, slice rewards_deposit_slice, int success2) = rewards_deposits.udict_get_min?(16);
                while (success2) {
                    int farming_speed = rewards_deposit_slice~load_coins();
                    int start_time = rewards_deposit_slice~load_uint(32);
                    int time_now = now();
                    if (start_time < time_now) {
                        int end_time = rewards_deposit_slice~load_uint(32);
                        if (end_time <= time_now) {
                            rewards_deposits~udict_delete?(32, index);
                            time_now = end_time;
                            should_update_rewards = true;
                            should_update_rewards2 = true;
                        }
                        distributed_rewards += get_distributed_rewards(farming_speed, start_time, time_now);
                        rewards_deposits~udict_set_builder(16, index, begin_cell().store_coins(farming_speed).store_uint(start_time, 32).store_uint(end_time, 32));
                    }
                }
                
                (slice prev_user_rewards_slice, int success3) = user_rewards_dict~dict_set_get_builder?(267, reward_jetton, begin_cell().store_uint(distributed_rewards, 256).store_coins(0));
                int prev_user_distributed_rewards = 0;
                int prev_user_unclaimed_rewards = 0;
                if (success3) {
                    prev_user_distributed_rewards = prev_user_rewards_slice~load_uint(256);
                    prev_user_unclaimed_rewards = prev_user_rewards_slice~load_coins();
                }
                int new_user_rewards = muldiv(distributed_rewards - prev_user_distributed_rewards, user_jetton_balance, distributed_rewards_devider);
                
                required_gas += send_jettons(query_id, new_user_rewards + prev_user_unclaimed_rewards, stake_owner_address, stake_owner_address, reward_jetton, 
                                             gas::jetton_transfer, 0, 1, begin_cell().store_uint(0, 32).store_slice("Claim staking rewards").end_cell());
                if (should_update_rewards2) {
                    storage::reward_jettons~dict_set_builder(267, reward_jetton, begin_cell().store_uint(distributed_rewards, 256).store_dict(rewards_deposits));
                }
            }
            (reward_jetton, _, success) = jettons_to_claim.dict_get_next?(267, reward_jetton);
        }

        if (should_update_rewards) {
            save_data();
        }

        builder payload = begin_cell().store_uint(op::update_rewards, 32).store_uint(query_id, 64).store_dict(user_rewards_dict);
        required_gas += send_builder_message(sender_address, 0, payload, mode::carry_remaining_balance);
        required_gas += get_compute_fee(0, gas_consumed() + 200);
        throw_unless(exc::out_of_gas, msg_value >= required_gas);
        return ();
    }

    if (op == op::request_update_rewards) {
        int user_jetton_balance = in_msg_body~load_coins();
        cell user_rewards_dict = in_msg_body~load_dict();

        (slice reward_jetton, slice rewards_info_slice, int success) = storage::reward_jettons.dict_get_min?(267);

        int should_update_rewards = false;  ;; надо ли удалять элементы из storage::reward_jettons для оптимизации? 
        while (success) {
            int should_update_rewards2 = false;
            int distributed_rewards = rewards_info_slice~load_uint(256);
            cell rewards_deposits = rewards_info_slice~load_dict();

            (int index, slice rewards_deposit_slice, int success2) = rewards_deposits.udict_get_min?(16);
            while (success2) {
                int farming_speed = rewards_deposit_slice~load_coins();
                int start_time = rewards_deposit_slice~load_uint(32);
                int time_now = now();
                if (start_time < time_now) {
                    int end_time = rewards_deposit_slice~load_uint(32);
                    if (end_time <= time_now) {
                        rewards_deposits~udict_delete?(32, index);
                        time_now = end_time;
                        should_update_rewards = true;
                        should_update_rewards2 = true;
                    }
                    distributed_rewards += get_distributed_rewards(farming_speed, start_time, time_now);
                    rewards_deposits~udict_set_builder(16, index, begin_cell().store_coins(farming_speed).store_uint(start_time, 32).store_uint(end_time, 32));
                }
            }
            
            (slice prev_user_rewards_slice, int success3) = user_rewards_dict.dict_get?(267, reward_jetton);
            int prev_user_distributed_rewards = 0;
            int user_unclaimed_rewards = 0;
            if (success3) {
                prev_user_distributed_rewards = prev_user_rewards_slice~load_uint(256);
                user_unclaimed_rewards = prev_user_rewards_slice~load_coins();
            }
            user_unclaimed_rewards += muldiv(distributed_rewards - prev_user_distributed_rewards, user_jetton_balance, distributed_rewards_devider);
            
            user_rewards_dict~dict_set_builder(267, reward_jetton, begin_cell().store_uint(distributed_rewards, 256).store_coins(user_unclaimed_rewards));
            if (should_update_rewards2) {
                storage::reward_jettons~dict_set_builder(267, reward_jetton, begin_cell().store_uint(distributed_rewards, 256).store_dict(rewards_deposits));
            }
            (reward_jetton, rewards_info_slice, success) = storage::reward_jettons.dict_get_next?(267, reward_jetton);
        }

        if (should_update_rewards) {
            save_data();
        }

        builder payload = begin_cell().store_uint(op::update_rewards, 32).store_uint(query_id, 64).store_dict(user_rewards_dict);
        send_builder_message(sender_address, 0, payload, mode::carry_remaining_gas);
        return ();
    }

    if (op == op::send_unstaked_jettons) {
        raw_reserve(0, 4);
        
        int jettons_to_send = in_msg_body~load_coins();
        int commission = in_msg_body~load_coins();
        
        send_message_with_comment(storage::admin_address, storage::unstake_fee, "Unstake commission", mode::simple);
        send_jettons(query_id, jettons_to_send, stake_owner_address, stake_owner_address, storage::lock_wallet_address, 0,
                     mode::carry_remaining_balance, 1, begin_cell().store_uint(0, 32).store_slice("Jettons unstaked").end_cell());

        (slice multiplier_slice, _) = storage::rewards_multipliers.udict_get?(32, lock_period);
        int multiplier = multiplier_slice~load_uint(16); 
        int tvl_decrease = jettons_to_send + commission;
        storage::tvl -= tvl_decrease;
        storage::tvl_with_multipliers -= muldiv(tvl_decrease, multiplier, rewards_devider);
        storage::collected_commissions += commission;
        
        save_data();
        return ();
    }
}
