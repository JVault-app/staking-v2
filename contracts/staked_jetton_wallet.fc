#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";


global slice storage::staking_pool_address;
global slice storage::owner_address;   

global int   storage::jetton_balance;
global cell  storage::rewards_dict;                 ;; HashMapE. reward jetton address (MsgAddressStd) -> last_distributed_rewards (uint256), unclaimed_rewards (coins)

global int   storage::lock_period;              ;; Uint32. Time to wait for free withdrawal
global cell  storage::unstake_requests;         ;; HashMapE. request_time (uint32) -> jettons_to_unstake (coins)
global int   storage::total_requested_jettons;

global int   storage::unstake_commission;       ;; Uint32. commission rate for instant unstakes
global int   storage::unstake_fee;              ;; Coins. const TON fee

global int   storage::is_active;            


() load_data() impure inline {
    slice ds = get_data().begin_parse();
    storage::staking_pool_address    = ds~load_msg_addr();
    storage::owner_address           = ds~load_msg_addr();   
    storage::jetton_balance          = ds~load_coins();
    storage::rewards_dict                 = ds~load_dict();                
    storage::lock_period             = ds~load_uint(32);              
    storage::unstake_requests        = ds~load_dict();         
    storage::total_requested_jettons = ds~load_coins();
    storage::unstake_commission      = ds~load_uint(32);
    storage::unstake_fee             = ds~load_coins();
    storage::is_active               = ds~load_int(1);   
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::staking_pool_address)
            .store_slice(storage::owner_address)
            .store_coins(storage::jetton_balance)
            .store_dict(storage::rewards_dict)
            .store_uint(storage::lock_period, 32)
            .store_dict(storage::unstake_requests)
            .store_coins(storage::total_requested_jettons)
            .store_uint(storage::unstake_commission, 32)
            .store_coins(storage::unstake_fee)
            .store_int(storage::is_active, 1)
        .end_cell()
    );
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }

    load_data();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);


    if (op == op::receive_jettons) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::staking_pool_address));

        int jettons_to_stake = in_msg_body~load_coins();
        int max_deposit = in_msg_body~load_coins();
        storage::jetton_balance += jettons_to_stake;
        
        if ((storage::jetton_balance > max_deposit) | (~ storage::is_active)) {
            cell payload = begin_cell()
                                .store_uint(op::cancel_stake, 32)
                                .store_uint(query_id, 64)
                                .store_slice(storage::owner_address)
                                .store_uint(storage::lock_period, 32)
                                .store_coins(jettons_to_stake)
                            .end_cell();
            send_cell_message(storage::staking_pool_address, 0, payload, mode::carry_remaining_gas);
            return ();
        }

        cell payload = begin_cell()
                            .store_uint(op::approve_stake, 32)
                            .store_uint(query_id, 64)
                            .store_slice(storage::owner_address)
                            .store_uint(storage::lock_period, 32)
                            .store_coins(storage::jetton_balance  - jettons_to_stake)
                            .store_coins(jettons_to_stake)
                            .store_dict(storage::rewards_dict)
                        .end_cell();
        send_cell_message(storage::staking_pool_address, 0, payload, mode::carry_remaining_gas);

        storage::is_active = false;
        save_data();
        return ();
    }

    if (op == op::claim_rewards) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::owner_address));
        
        cell payload = begin_cell()
                            .store_uint(op::send_claimed_rewards, 32)
                            .store_uint(query_id, 64)
                            .store_slice(storage::owner_address)
                            .store_uint(storage::lock_period, 32)
                            .store_coins(storage::jetton_balance)
                            .store_dict(storage::rewards_dict)
                            .store_slice(in_msg_body)                 ;; in_msg_body = HashMapE. jetton_address (MsgAddressStd) -> nothing (int1)
                        .end_cell();
        send_cell_message(storage::staking_pool_address, 0, payload, mode::carry_remaining_gas);
        storage::is_active = false;
        
        save_data();
        return ();
    }

    if (op == op::unstake_request) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::owner_address));
        
        int jettons_to_unstake = in_msg_body~load_coins();
        in_msg_body.end_parse();

        storage::jetton_balance -= jettons_to_unstake;
        storage::total_requested_jettons += jettons_to_unstake;
        throw_unless(exc::not_enough_jettons, storage::total_requested_jettons <= storage::jetton_balance);

        (slice requested_jettons_slice, int success) = storage::unstake_requests.udict_get?(32, now());
        if (success) {
            jettons_to_unstake += requested_jettons_slice~load_coins();
        }
        storage::unstake_requests~udict_set_builder(32, now(), begin_cell().store_coins(jettons_to_unstake));
        
        send_excess(storage::owner_address, query_id, 0, mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::unstake_jettons) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::owner_address));
        throw_unless(exc::out_of_gas, msg_value >= storage::unstake_fee + gas::unstake_jettons);
        int jettons_to_unstake = in_msg_body~load_coins();
        int force_unstake = in_msg_body~load_uint(1);
        in_msg_body.end_parse();

        throw_unless(exc::not_enough_jettons, jettons_to_unstake <= storage::total_requested_jettons + force_unstake * storage::jetton_balance);
        
        int jettons_to_send = 0;
        int tmp = jettons_to_unstake;
        (int request_time, slice requested_jettons_slice, int success) = storage::unstake_requests.udict_get_preveq?(32, now() - storage::lock_period);
        while (success & tmp) {
            int requested_jettons = requested_jettons_slice~load_coins();
            if (requested_jettons <= tmp) {
                storage::unstake_requests~udict_delete?(32, request_time);
            } else {
                storage::unstake_requests~udict_set_builder(32, request_time, begin_cell().store_coins(requested_jettons - tmp));
                requested_jettons = tmp;
            }
            tmp -= requested_jettons;
            jettons_to_send += requested_jettons;
            (request_time, requested_jettons_slice, success) = storage::unstake_requests.udict_get_prev?(32, request_time);
        }
        if (tmp) {
            jettons_to_send += muldiv(tmp, storage::unstake_commission, commission_devider);
        }

        storage::total_requested_jettons -= (jettons_to_unstake - tmp);
        storage::jetton_balance -= tmp;
        
        cell payload = begin_cell()
                        .store_uint(op::send_unstaked_jettons, 32)
                        .store_uint(query_id, 64)
                        .store_slice(storage::owner_address)
                        .store_uint(storage::lock_period, 32)
                        .store_coins(jettons_to_send)
                        .store_coins(jettons_to_unstake - jettons_to_send)  ;; commission
                    .end_cell();
        send_cell_message(storage::staking_pool_address, 0, payload, mode::carry_remaining_gas);

        save_data();
        return ();
    }

    if (op == op::cancel_unstake_request) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::owner_address));
        
        cell payload = begin_cell()
                            .store_uint(op::request_update_rewards, 32)
                            .store_uint(query_id, 64)
                            .store_coins(storage::jetton_balance)
                            .store_dict(storage::rewards_dict)
                        .end_cell();
        send_cell_message(storage::staking_pool_address, 0, payload, mode::carry_remaining_gas);

        cell requests_to_cancel = in_msg_body~load_dict();
        (int request_time, _, int success) = requests_to_cancel.udict_get_min?(32);
        while (success) {
            (slice requested_jettons_slice, int success2) = storage::unstake_requests~udict_delete_get?(32, request_time);
            if (success2) {
                int requested_jettons = in_msg_body~load_coins(); 
                storage::jetton_balance += requested_jettons;
                storage::total_requested_jettons -= requested_jettons;
            }
        }
        
        storage::is_active = false;
        save_data();
        return ();
    }

    if (op == op::update_rewards) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::staking_pool_address));
        
        storage::rewards_dict = in_msg_body~load_dict();
        storage::is_active = true;
        send_excess(storage::owner_address, query_id, 0, mode::carry_remaining_gas);
        
        save_data();
        return ();
    }
    ;; if (op == op::unstake_user_request)
}


(slice, slice, int, cell, int, cell, int, int, int, int) get_storage_data() method_id {
    load_data();
    return (
        storage::staking_pool_address,
        storage::owner_address,
        storage::jetton_balance,
        storage::rewards_dict,            
        storage::lock_period,
        storage::unstake_requests,         
        storage::total_requested_jettons,
        storage::unstake_commission,
        storage::unstake_fee,
        storage::is_active  
    );
}